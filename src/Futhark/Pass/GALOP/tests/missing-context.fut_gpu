types {

}



entry("main",
      {x: i64,
       y: i64},
      {[]i64})
  entry_main (x_5411 : i64,
              y_5412 : i64)
  : {[x_5411]i64#([], [0])} = {
  let {b_5517 : i64} =
    add64(2i64, y_5412)
  let {bounds_invalid_upwards_5518 : bool} =
    slt64(x_5411, 0i64)
  let {valid_5519 : bool} =
    not bounds_invalid_upwards_5518
  let {range_valid_c_5520 : unit} =
    assert(valid_5519, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", x_5411 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
  let {segmap_group_size_5575 : i64} =
    get_size(segmap_group_size_5558, group_size)
  let {segmap_usable_groups_5576 : i64} =
    sdiv_up64(x_5411, segmap_group_size_5575)
  let {defunc_0_map_res_5577 : [x_5411]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5576; groupsize=segmap_group_size_5575)
    (gtid_5578 < x_5411) (~phys_tid_5579) : {i64} {
      let {lifted_lambda_res_5581 : i64} =
        loop {acc_5583 : i64} = {0i64}
        for i_5582:i64 < x_5411 do {
          let {a_5584 : i64} =
            add64(b_5517, acc_5583)
          let {+_lhs_5585 : i64} =
            add64(acc_5583, a_5584)
          let {zero_5586 : bool} =
            eq_i64(i_5582, 0i64)
          let {nonzero_5587 : bool} =
            not zero_5586
          let {nonzero_cert_5588 : unit} =
            assert(nonzero_5587, {"division by zero"}, "/Users/bak/Desktop/Speciale/futhark/tests_analysis/missing-context.fut:6:21-24")
          let {+_rhs_5589 : i64} =
            #{range_valid_c_5520, nonzero_cert_5588}
            sdiv64(gtid_5578, i_5582)
          let {loopres_5590 : i64} =
            add64(+_lhs_5585, +_rhs_5589)
          in {loopres_5590}
        }
      return {returns lifted_lambda_res_5581}
    }
  let {w_minus_1_5534 : i64} =
    sub64(x_5411, 1i64)
  let {segmap_group_size_5603 : i64} =
    get_size(segmap_group_size_5594, group_size)
  let {segmap_usable_groups_5604 : i64} =
    sdiv_up64(x_5411, segmap_group_size_5603)
  let {defunc_0_map_res_5605 : [x_5411]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5604; groupsize=segmap_group_size_5603)
    (gtid_5606 < x_5411) (~phys_tid_5607) : {i64} {
      let {eta_p_5608 : i64} =
        defunc_0_map_res_5577[gtid_5606]
      let {slice_5612 : i64} =
        sub_nw64(w_minus_1_5534, gtid_5606)
      let {eta_p_5609 : i64} =
        defunc_0_map_res_5577[slice_5612]
      let {defunc_0_f_res_5610 : i64} =
        add64(eta_p_5608, eta_p_5609)
      return {returns defunc_0_f_res_5610}
    }
  in {defunc_0_map_res_5605}
}


-- === Expected output after pass: CONFIRMED
-- types {
--
-- }
--
--
--
-- entry("main",
--       {x: i64,
--        y: i64},
--       {[]i64})
--   entry_main (x_5411 : i64,
--               y_5412 : i64)
--   : {[x_5411]i64#([], [0])} = {
--   let {b_5517 : i64} =
--     add64(2i64, y_5412)
--   let {bounds_invalid_upwards_5518 : bool} =
--     slt64(x_5411, 0i64)
--   let {valid_5519 : bool} =
--     not bounds_invalid_upwards_5518
--   let {range_valid_c_5520 : unit} =
--     assert(valid_5519, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", x_5411 : i64, " is invalid."}, "unknown location")
--   let {segmap_group_size_5575 : i64} =
--     get_size(segmap_group_size_5558, group_size)
--   let {segmap_usable_groups_5576 : i64} =
--     sdiv_up64(x_5411, segmap_group_size_5575)
--   let {defunc_0_map_res_5577 : [x_5411]i64} =
--     segmap(thread; ; groups=segmap_usable_groups_5576; groupsize=segmap_group_size_5575)
--     (gtid_5578 < x_5411) (~phys_tid_5579) : {i64} {
--       let {lifted_lambda_res_5581 : i64} =
--         loop {acc_5583 : i64} = {0i64}
--         for i_5582:i64 < x_5411 do {
--           let {a_5584 : i64} =
--             add64(b_5517, acc_5583)
--           let {+_lhs_5585 : i64} =
--             add64(acc_5583, a_5584)
--           let {zero_5586 : bool} =
--             eq_i64(i_5582, 0i64)
--           let {nonzero_5587 : bool} =
--             not zero_5586
--           let {nonzero_cert_5588 : unit} =
--             assert(nonzero_5587, {"division by zero"}, "unknown location")
--           let {+_rhs_5589 : i64} =
--             #{range_valid_c_5520, nonzero_cert_5588}
--             sdiv64(gtid_5578, i_5582)
--           let {loopres_5590 : i64} =
--             add64(+_lhs_5585, +_rhs_5589)
--           in {loopres_5590}
--         }
--       return {returns lifted_lambda_res_5581}
--     }
--   let {w_minus_1_5534 : i64} =
--     sub64(x_5411, 1i64)
--   let {segmap_group_size_5603 : i64} =
--     get_size(segmap_group_size_5594, group_size)
--   let {segmap_usable_groups_5604 : i64} =
--     sdiv_up64(x_5411, segmap_group_size_5603)
--   let {defunc_0_map_res_5605 : [x_5411]i64} =
--     segmap(thread; ; groups=segmap_usable_groups_5604; groupsize=segmap_group_size_5603)
--     (gtid_5606 < x_5411) (~phys_tid_5607) : {i64} {
--       let {eta_p_5608 : i64} =
--         defunc_0_map_res_5577[gtid_5606]
--       let {slice_5612 : i64} =
--         sub_nw64(w_minus_1_5534, gtid_5606)
--       let {eta_p_5609 : i64} =
--         defunc_0_map_res_5577[slice_5612]
--       let {defunc_0_f_res_5610 : i64} =
--         add64(eta_p_5608, eta_p_5609)
--       return {returns defunc_0_f_res_5610}
--     }
--   in {defunc_0_map_res_5605}
-- }
