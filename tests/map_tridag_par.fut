-- A map of a parallel tridag.  This is intended to test
-- parallelisation of the inner scans and maps.  The real test for
-- this is LocVolCalib.
--
-- ==
-- input {
--
--  [[0.74242944f32, 0.1323092f32, 1.3599575e-2f32], [0.42590684f32,
-- 0.28189754f32, 0.71788645f32], [0.120514154f32, 0.3523355f32,
-- 0.97101444f32], [0.8475803f32, 0.88611674f32, 0.9148224f32],
-- [0.94415265f32, 0.14399022f32, 0.5325674f32], [0.659268f32,
-- 0.7296194f32, 0.6609876f32], [6.526101e-2f32, 6.5751016e-2f32,
-- 0.95010173f32], [0.14800721f32, 0.94630295f32, 0.53180677f32],
-- [0.50352955f32, 0.8683887f32, 0.52372944f32], [0.56981534f32,
-- 0.89906573f32, 0.28717548f32], [0.33396137f32, 0.1774621f32,
-- 0.38886482f32], [0.9896543f32, 0.46158296f32, 0.3661f32],
-- [0.3473122f32, 0.3432145f32, 0.8394218f32], [0.99296236f32,
-- 0.121897876f32, 9.7216845e-2f32], [0.9392534f32, 0.21994972f32,
-- 0.48229688f32], [0.655326f32, 0.7612596f32, 0.87178886f32]]
--
-- [[0.97108245f32, 0.7680431f32, 0.31416982f32], [0.9500684f32,
-- 0.92118263f32, 0.64046925f32], [0.755465f32, 0.32811958f32,
-- 0.83344376f32], [0.72276676f32, 0.41465372f32, 0.3278041f32],
-- [0.30799133f32, 0.9324039f32, 0.27047098f32], [0.19988102f32,
-- 0.19318312f32, 0.64125025f32], [4.098314e-2f32, 0.8863338f32,
-- 0.8044033f32], [0.12424153f32, 0.5909478f32, 0.41370803f32],
-- [0.79128355f32, 0.694645f32, 0.9142884f32], [0.14140934f32,
-- 0.8434962f32, 0.18492651f32], [0.9224554f32, 0.3886028f32,
-- 0.3522579f32], [0.9237198f32, 0.67486274f32, 0.94845694f32],
-- [0.45179868f32, 0.4121315f32, 0.46043044f32], [0.3489151f32,
-- 2.9113293e-3f32, 6.279576e-2f32], [8.110166e-3f32, 0.34567893f32,
-- 0.7421653f32], [0.9538966f32, 0.2953536f32, 0.688568f32]]
--
-- [[0.2001763f32, 0.4042127f32, 0.6147452f32, 0.47423f32,
-- 0.5609137f32, 0.56305206f32, 0.3904158f32, 0.30390364f32,
-- 0.6954271f32, 0.5979532f32, 0.9436264f32, 0.7407909f32,
-- 0.67227083f32, 0.7208228f32, 8.374572e-3f32, 0.740494f32],
-- [0.65674686f32, 0.62107205f32, 1.7156303e-2f32, 0.70735234f32,
-- 0.65825886f32, 0.10002482f32, 0.2360335f32, 0.29516333f32,
-- 7.859665e-2f32, 0.52089614f32, 0.30484223f32, 0.71300334f32,
-- 0.78793174f32, 8.268273e-2f32, 0.5109494f32, 0.59974855f32]]
--
-- [[0.4292702f32, 3.9946616e-2f32, 0.9148746f32, 0.99839664f32,
-- 0.2002039f32, 0.48563486f32, 2.5366604e-2f32, 0.279252f32,
-- 0.5578513f32, 0.47314477f32, 0.4725991f32, 0.15377778f32,
-- 3.6550343e-2f32, 0.50924164f32, 0.7462731f32, 0.281107f32],
-- [0.12030554f32, 0.60089386f32, 0.9933193f32, 0.52793f32,
-- 0.51211447f32, 7.6259136e-2f32, 0.88067836f32, 0.17662883f32,
-- 0.36635065f32, 0.3471524f32, 0.6958369f32, 0.28503305f32,
-- 0.7323622f32, 0.9804389f32, 9.900254e-2f32, 0.81132495f32]]
--
-- [[0.65835893f32, 0.6756856f32, 0.21544486f32, 0.5225582f32,
-- 0.83949417f32, 0.40821767f32, 0.6603174f32, 0.25503606f32,
-- 0.42028064f32, 0.34789038f32, 1.5769005e-3f32, 0.5667646f32,
-- 0.40082985f32, 0.2980911f32, 0.4841767f32, 0.82172f32],
-- [0.5838693f32, 0.58071566f32, 0.9690465f32, 0.34851283f32,
-- 0.3664109f32, 5.2042425e-2f32, 0.52532834f32, 5.8530092e-2f32,
-- 0.6536586f32, 0.17340869f32, 8.6390674e-2f32, 0.8566219f32,
-- 0.67679775f32, 0.8781899f32, 0.68750167f32, 2.2470713e-2f32]]
--
-- 0.8874528f32
--
-- }
-- output {
-- [[0.91598815f32, 1.9074391f32, 5.3029337f32, 6.3754444f32,
-- 3.727485f32, 2.1948073f32, 0.96606904f32, 0.790595f32,
-- 2.4630525f32, 1.8008121f32, 1.1668242f32, 1.7887846f32,
-- 1.1583511f32, 0.9531149f32, 0.9185418f32, 1.8913889f32],
-- [0.7588583f32, 2.8086615f32, 3.3484242f32, 5.526025f32,
-- 3.266317f32, 0.24999757f32, 0.87522936f32, 0.24073343f32,
-- 0.9435158f32, 0.6636466f32, 0.6600369f32, 2.4604933f32,
-- 2.6624017f32, 1.4092984f32, 1.4115977f32, 0.9561525f32]]
-- }

default (f32)

fun tridagPar(a:  [n]f32, b: *[]f32, c: []f32, y: *[]f32 ): *[]f32 =
  unsafe
----------------------------------------------------
  -- Recurrence 1: b[i] = b[i] - a[i]*c[i-1]/b[i-1] --
  --   solved by scan with 2x2 matrix mult operator --
  ----------------------------------------------------
  let b0   = b[0]
  let mats = map  (\(i: i32): (f32,f32,f32,f32)  ->
                     if 0 < i
                     then (b[i], 0.0-a[i]*c[i-1], 1.0, 0.0)
                     else (1.0,  0.0,             0.0, 1.0)
                  ) (iota n)
  let scmt = scan (\(a:  (f32,f32,f32,f32))
                   (b: (f32,f32,f32,f32)): (f32,f32,f32,f32)  ->
                     let (a0,a1,a2,a3) = a
                     let (b0,b1,b2,b3) = b
                     let value = 1.0/(a0*b0)
                     in ( (b0*a0 + b1*a2)*value,
                          (b0*a1 + b1*a3)*value,
                          (b2*a0 + b3*a2)*value,
                          (b2*a1 + b3*a3)*value
                        )
                  ) (1.0,  0.0, 0.0, 1.0) mats
  let b    = map  (\(tup: (f32,f32,f32,f32)): f32  ->
                     let (t0,t1,t2,t3) = tup
                     in (t0*b0 + t1) / (t2*b0 + t3)
                  ) scmt
  ------------------------------------------------------
  -- Recurrence 2: y[i] = y[i] - (a[i]/b[i-1])*y[i-1] --
  --   solved by scan with linear func comp operator  --
  ------------------------------------------------------
  let y0   = y[0]
  let lfuns= map  (\(i: i32): (f32,f32)  ->
                     if 0 < i
                     then (y[i], 0.0-a[i]/b[i-1])
                     else (0.0,  1.0            )
                  ) (iota n)
  let cfuns= scan (\(a: (f32,f32)) (b: (f32,f32)): (f32,f32)  ->
                     let (a0,a1) = a
                     let (b0,b1) = b
                     in ( b0 + b1*a0, a1*b1 )
                  ) (0.0, 1.0) lfuns
  let y    = map  (\(tup: (f32,f32)): f32  ->
                     let (a,b) = tup
                     in a + b*y0
                  ) cfuns
  ------------------------------------------------------
  -- Recurrence 3: backward recurrence solved via     --
  --             scan with linear func comp operator  --
  ------------------------------------------------------
  let yn   = y[n-1]/b[n-1]
  let lfuns= map  (\(k: i32): (f32,f32)  ->
                     let i = n-k-1
                     in  if   0 < k
                         then (y[i]/b[i], 0.0-c[i]/b[i])
                         else (0.0,       1.0          )
                  ) (iota n)
  let cfuns= scan (\(a: (f32,f32)) (b: (f32,f32)): (f32,f32)  ->
                     let (a0,a1) = a
                     let (b0,b1) = b
                     in (b0 + b1*a0, a1*b1)
                  ) (0.0, 1.0) lfuns
  let y    = map  (\(tup: (f32,f32)): f32  ->
                     let (a,b) = tup
                     in a + b*yn
                  ) cfuns
  let y    = map  (\(i: i32): f32  -> y[n-i-1]) (iota n)
  in y

fun main(myD:  [inner][3]f32, myDD: [inner][3]f32,
         myMu: [outer][inner]f32,  myVar: [outer][inner]f32,
         u:   *[outer][inner]f32,  dtInv: f32  ): *[][]f32 =
  map (\mu_row var_row (u_row: *[]f32): *[inner]f32  ->
             let abc = map (\mu var d dd: (f32,f32,f32)  ->
                                  ( 0.0   - 0.5*(mu*d[0] + 0.5*var*dd[0])
                                  , dtInv - 0.5*(mu*d[1] + 0.5*var*dd[1])
                                  , 0.0   - 0.5*(mu*d[2] + 0.5*var*dd[2])
                                  )
                               ) mu_row var_row myD myDD
             let (a,b,c) = unzip(abc)
             in tridagPar( a, b, c, u_row )
          ) myMu myVar u
