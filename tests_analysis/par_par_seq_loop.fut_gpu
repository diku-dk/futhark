-- Source code:

-- def main [l][n][m] (xsss: [l][n][m]i64) : [l][n]i64 =
--   map (\xss ->
--     map (\xs ->
--       #[unsafe]
--       loop res=xs[0] for i < n do
--         res + xs[i]
--     ) xss
--   ) xsss

-- IR:

types {

}



entry("main",
      {xsss: [][][]i64},
      {[][]i64})
  entry_main (l_5238 : i64,
              n_5239 : i64,
              m_5240 : i64,
              xsss_5241 : [l_5238][n_5239][m_5240]i64)
  : {[l_5238][n_5239]i64#([3], [0])} = {
  let {nest_size_5387 : i64} =
    mul_nw64(l_5238, n_5239)
  let {segmap_group_size_5388 : i64} =
    get_size(segmap_group_size_5354, group_size)
  let {segmap_usable_groups_5389 : i64} =
    sdiv_up64(nest_size_5387, segmap_group_size_5388)
  let {defunc_0_map_res_5390 : [l_5238][n_5239]i64} =
    segmap(thread; ; groups=segmap_usable_groups_5389; groupsize=segmap_group_size_5388)
    (gtid_5391 < l_5238, gtid_5392 < n_5239) (~phys_tid_5393) : {i64} {
      let {tmp_5395 : i64} =
        xsss_5241[gtid_5391, gtid_5392, 0i64]
      let {lifted_lambda_res_5396 : i64} =
        loop {res_5398 : i64} = {tmp_5395}
        for i_5397:i64 < n_5239 do {
          let {+_rhs_5399 : i64} =
            xsss_5241[gtid_5391, gtid_5392, i_5397]
          let {loopres_5400 : i64} =
            add64(res_5398, +_rhs_5399)
          in {loopres_5400}
        }
      return {returns lifted_lambda_res_5396}
    }
  in {defunc_0_map_res_5390}
}

-- === Expected output of analysis: CONFIRMED
-- (segmap) defunc_0_map_res_5390 : {
--     (arr) xsss_5241 : [0, 1, 2] {
--         (idx) tmp_5395 :
--             0 : dependencies = {gtid_5391 0 tid}
--             1 : dependencies = {gtid_5392 1 tid}
--             2 : dependencies = {}
--         (idx) +_rhs_5399 :
--             0 : dependencies = {gtid_5391 0 tid}
--             1 : dependencies = {gtid_5392 1 tid}
--             2 : dependencies = {i_5397 2 iter}
--     }
-- }
